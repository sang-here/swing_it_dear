전선면 볼륨

<<선이 주는 효과>>
가로선, 세로선, 수직선, 사선 등
횡단보도, 가로선들은 전두옆에 자극을 주어 행동을 통제한다.

---

<언리얼로 만든 영화, Rally; thriller short film>

각종 사선(그림자, 프레임 구조 등)으로 긴장감 조성
아기 가족 사진으로 긴장 대비 강조 (엔딩에서 다시 나오는 그 사진은 다시 안정화를 부여)
시각 - 굉장히 능동적이고 즉각적인 정보 처리 -> 긴장 상황(생존적)
시계 - 계획, 제한, 긴박
흑백과 빛으로 대비 & 제한적인 색 허용으로 강조 대비
속도
sci fi 적 사운드
엔딩 크레딧 색도 고려되어 있음

(카메라 위치에 따라 같은 씬도 다름)
(보통 look and track but, here you get look and away)
(사운드와 씬의 조화, 시간 초 소리 + 클로즈 업 농축화 = climax)

--
(카메라 축을 꺽어 바닥을 보여주다가, 대상을 show up하면 웅장 효과)
(대상에 도달 전 언덕에 대상을 순간 숨겨지게 만들고 다시 등장하게 효과)

--

(격탄 씬, 측면, 후면, 바로 측면 클로즈업)

---
---


(조명이 있는 길은 인도된 가이드가 있는 길)

---
----
---


<<색론>>

이런 방법론이 있음; 찬 색, 따듯한 색, 중립색, 명도, 채도

보색 = 색상 테이블에서 서로 마주보는 색 -> ex) 초록 - 보라 , 노랑 - 파랑
인접 보색 -> ex) 초록 - 빨강 파랑 스므리
인접 유색 ->

노랑색이 같은 채도이면 명도가 가장 높음 -> 검정에서 노랑색이 가장 대비
ambient 익숙한 주변색 = 하늘색, 파랑색,초록색

---
---
---

<<모델링>>

(삼격형 피하고 최소 단위는 사각형이 좋음, 삼각형은 나중에 튀어나오는 현상이 있을 수 있고 추후 조정에 불리 할 수 있음)

-블렌더에서 모델의 피봇 위치를 잘 정해주어야 언리얼에 임포트시 오류를 줄일 수 있음
-임포트 전에 transform(scale, rotation, location), dimension(size)들도 다 잘 맞추어 두어야 함

---

<world>object>element>mesh>

object의 transform과 world에서 n 눌러서 나오는 transform은 약간 다름. world에서 n눌러 나오는 transform은 vertex 컨드롤(수치 입력해서 각자운용) 가능

shift + space = cursor change
shift + z != alt + z 

(~표시 클릭으로도 숫자패드 대신 이동 가능)
(숫자패드 숫자말고 키보드 숫자는 아웃라이너에서의 오브젝트 간 이동 단축)

---

<bride> - 의자 만들기, 컵 만들기

두면 잡고 우클릭 후 bridge

(키에 우클릭 후 assign shorcut 하면 커스텀 short-cuts 생성 가능)

---

<컵 만들기>

모델링은 좌우대칭, 상하대칭을 매우 염두함 (짝홀수도 염두) (mirror 해서 하는 작업이 많으니) -> 컵의 cylinder의 각 수도 잘 확인 해야 함

(원 형태의 최소 크기인 폴리곤 = 5 각형 / 아주 예외로 3각형도 씀)

---

<최적화>

면들을 모두 3각형(better) 혹은 4각형(okay)으로 만들기 (균일하게 만들어야 수정이 좋음) (프로그램이 자동으로 결국 3각형으로 만들지만, 사람 손으로 정리해두어야 균일하고 편집하기 좋게 만들어짐)

(불필요한 모든 선과 점 ctrl + x로 싹다 지움 = 최적화)
(vertices를 순서대로 클릭 후 merge 하면 first와 last도 나옴. 그러면 그거 맞게 병합 가능)

----

<비행기 만들기>
(shade auto smooth는 그 각도 이상은 직각 표현 그 이하는 굴곡지게 만듦 / normal 값만 인식해서)

벡터 = 위치 & 방향 
*벡터와 노말의 관계 제대로 잘 이해하기

-------

<그릇 만들기>

ctrl + a = apply 안 해주면, 바뀌기 전의 모습의 노멀 기준으로 피봇이 적용됨

1. modifier - simpleDeform - stretch (=둥글게 만들기 modifier 사용으로 손 쉽게)
2. modifier - solidify (= 두께 부여)

3. convert to mesh

4. modifier - subdivision = turbo smooth (level을 올릴 때 마다 2의 제곱으로 면이 늘어나서 스무스 해짐)
-> 문제점, 각져야 할 부분도 뭉게짐 => 해당 부분(튀어나온 부분과 각진 부분)을 잡고 bevel을 주어서 살짝 겹치게 만들어 줌. (= 폭사이 너무 좁아지면 각지게 보여짐)

(구글 docs들 뭐든, 글과 이미지로 정리하면서 하세유 / 레퍼런스가 재산)


---
<ex>

(curve가 균등하게 geometry-bevel되지 않는 이유는 scale 때문일 수도 있음. ctrl + a 하시오. )

커브 오브젝트의 Bevel은 내부적으로 커브의 지오메트리 데이터를 기반으로 메쉬를 생성하는 과정입니다. 이 과정에서 Bevel의 두께(Depth)는 **"오브젝트의 로컬(Local) 축"**을 기준으로 계산됩니다.

Blender에서 커브(Curve)의 Object Scale을 적용하지 않았을 때 Bevel 두께가 불균일해지는 원리는 오브젝트 변환(Object Transformation)과 메쉬 데이터(Mesh Data)의 분리 때문입니다.
간단히 말해, 블렌더에서 오브젝트를 {Edit Mode}가 아닌 {Object Mode}에서 스케일(Scale)을 변경하면, 실제 커브의 지오메트리 데이터(Mesh Data) 자체는 변경되지 않고, 단지 뷰포트에서 보여지는 **오브젝트 전체에 대한 변환 행렬(Transformation Matrix)**만 변경됩니다.



